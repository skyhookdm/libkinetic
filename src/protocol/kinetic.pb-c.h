/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: kinetic.proto */

#ifndef PROTOBUF_C_kinetic_2eproto__INCLUDED
#define PROTOBUF_C_kinetic_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Com__Seagate__Kinetic__Proto__Local Com__Seagate__Kinetic__Proto__Local;
typedef struct _Com__Seagate__Kinetic__Proto__Message Com__Seagate__Kinetic__Proto__Message;
typedef struct _Com__Seagate__Kinetic__Proto__Message__HMACauth Com__Seagate__Kinetic__Proto__Message__HMACauth;
typedef struct _Com__Seagate__Kinetic__Proto__Message__PINauth Com__Seagate__Kinetic__Proto__Message__PINauth;
typedef struct _Com__Seagate__Kinetic__Proto__Command Com__Seagate__Kinetic__Proto__Command;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Header Com__Seagate__Kinetic__Proto__Command__Header;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Body Com__Seagate__Kinetic__Proto__Command__Body;
typedef struct _Com__Seagate__Kinetic__Proto__Command__PowerManagement Com__Seagate__Kinetic__Proto__Command__PowerManagement;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Batch Com__Seagate__Kinetic__Proto__Command__Batch;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Status Com__Seagate__Kinetic__Proto__Command__Status;
typedef struct _Com__Seagate__Kinetic__Proto__Command__KeyValue Com__Seagate__Kinetic__Proto__Command__KeyValue;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Range Com__Seagate__Kinetic__Proto__Command__Range;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Setup Com__Seagate__Kinetic__Proto__Command__Setup;
typedef struct _Com__Seagate__Kinetic__Proto__Command__P2POperation Com__Seagate__Kinetic__Proto__Command__P2POperation;
typedef struct _Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation;
typedef struct _Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog Com__Seagate__Kinetic__Proto__Command__GetLog;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Limits Com__Seagate__Kinetic__Proto__Command__GetLog__Limits;
typedef struct _Com__Seagate__Kinetic__Proto__Command__GetLog__Device Com__Seagate__Kinetic__Proto__Command__GetLog__Device;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Security Com__Seagate__Kinetic__Proto__Command__Security;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Security__ACL Com__Seagate__Kinetic__Proto__Command__Security__ACL;
typedef struct _Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope;
typedef struct _Com__Seagate__Kinetic__Proto__Command__PinOperation Com__Seagate__Kinetic__Proto__Command__PinOperation;


/* --- enums --- */

/*
 * The Message Type determines how the the message is to be processed.
 */
typedef enum _Com__Seagate__Kinetic__Proto__Message__AuthType {
  /*
   * if the message type is unknown, close the connection
   */
  COM__SEAGATE__KINETIC__PROTO__MESSAGE__AUTH_TYPE__INVALID_AUTH_TYPE = -1,
  /*
   * This is for normal traffic. Check the HMAC of the command and
   * if correct, process the command.
   */
  COM__SEAGATE__KINETIC__PROTO__MESSAGE__AUTH_TYPE__HMACAUTH = 1,
  /*
   * device unlock and ISE command. These must come over the TLS connection.
   * If they do not, close the connection. If it is over
   * the TLS connection, execute the pin operation.
   */
  COM__SEAGATE__KINETIC__PROTO__MESSAGE__AUTH_TYPE__PINAUTH = 2,
  /*
   * In the event that the device needs to communicate with the user
   */
  COM__SEAGATE__KINETIC__PROTO__MESSAGE__AUTH_TYPE__UNSOLICITEDSTATUS = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__MESSAGE__AUTH_TYPE)
} Com__Seagate__Kinetic__Proto__Message__AuthType;
/*
 *enum of status code
 */
typedef enum _Com__Seagate__Kinetic__Proto__Command__Status__StatusCode {
  /*
   * Must come first, so default is invalid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__INVALID_STATUS_CODE = -1,
  /*
   *  for a P2P operation, there was a reason the list was incomplete. This is for items
   * that were not attempted.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NOT_ATTEMPTED = 0,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__SUCCESS = 1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__HMAC_FAILURE = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NOT_AUTHORIZED = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__VERSION_FAILURE = 4,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__INTERNAL_ERROR = 5,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__HEADER_REQUIRED = 6,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NOT_FOUND = 7,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__VERSION_MISMATCH = 8,
  /*
   * If there are too many requests in the device at this time, requests
   * will be rejected with this error message. The common response is to
   * wait and retry the operation with an exponential back-off.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__SERVICE_BUSY = 9,
  /*
   * A long operation was started and a timeout happened mid operation. This
   * does not imply a failure.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__EXPIRED = 10,
  /*
   * A data error happened and either earlyExit was set or the timeout happened.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__DATA_ERROR = 11,
  /*
   * A data error happened and all possible error recovery operations have been
   * performed. There is no value to trying this again. If the system has the ability
   * to determine the correct information, writing the data again can get rid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__PERM_DATA_ERROR = 12,
  /*
   * A TCP connection to the remote peer failed. This is only for the P2P Operation
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__REMOTE_CONNECTION_ERROR = 13,
  /*
   * When the device is full, it returns this error. The background scrubbing may free space,
   * so this error may go away
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NO_SPACE = 14,
  /*
   * In the set security, an HmacAlgorithm was specified as Unknown or there is a protocol
   * version mis-match
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NO_SUCH_HMAC_ALGORITHM = 15,
  /*
   * The request is not valid. Subsequent attempts with the same request will return the same code.
   * Example: PUT a key whose size exceeds the specified maxKeySize in limits.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__INVALID_REQUEST = 16,
  /*
   * For P2P Requests, the operation was executed successfully but some nested operations
   * did not succeed. This indicates that callers should review the status of nested operations.
   * This status should only be used in the Command > Status, not in the Status messages
   * of nested P2POperations
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__NESTED_OPERATION_ERRORS = 17,
  /*
   * If the device is currently locked
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__DEVICE_LOCKED = 18,
  /*
   * The device is already unlocked.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__DEVICE_ALREADY_UNLOCKED = 19,
  /*
   * The connection is being terminated. Details as to why are
   * in the message string.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__CONNECTION_TERMINATED = 20,
  /*
   * The batch request is not valid. Subsequent attempts with the same batch request will return the
   * same code. Example: A batch that contains a command other than put or delete.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__INVALID_BATCH = 21,
  /*
   * the status is returned to caller if commands are received when
   * device is in hibernate state
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__HIBERNATE = 22,
  /*
   * the status is returned to caller if commands are received when
   * device is shutting down.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE__SHUTDOWN = 23
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__STATUS_CODE)
} Com__Seagate__Kinetic__Proto__Command__Status__StatusCode;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Setup__SetupOpType {
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SETUP__SETUP_OP_TYPE__INVALID_SETUPOP = -1,
  /*
   * This setup command is to issue a firmware update
   * There is a firmware load in the data portion of this message. 
   * The firmware is itself protected on its own for integrity,
   * authenticity, etc.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SETUP__SETUP_OP_TYPE__FIRMWARE_SETUPOP = 1,
  /*
   * This setup command is to update the cluster version
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SETUP__SETUP_OP_TYPE__CLUSTER_VERSION_SETUPOP = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__SETUP__SETUP_OP_TYPE)
} Com__Seagate__Kinetic__Proto__Command__Setup__SetupOpType;
typedef enum _Com__Seagate__Kinetic__Proto__Command__GetLog__Type {
  /*
   * Must come first, so default is invalid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__INVALID_TYPE = -1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__UTILIZATIONS = 0,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__TEMPERATURES = 1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__CAPACITIES = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__CONFIGURATION = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__STATISTICS = 4,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__MESSAGES = 5,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__LIMITS = 6,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE__DEVICE = 7
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TYPE)
} Com__Seagate__Kinetic__Proto__Command__GetLog__Type;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Security__ACL__HMACAlgorithm {
  /*
   * Must come first
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__HMACALGORITHM__INVALID_HMAC_ALGORITHM = -1,
  /*
   * 0 is reserved; do not use
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__HMACALGORITHM__HmacSHA1 = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__HMACALGORITHM)
} Com__Seagate__Kinetic__Proto__Command__Security__ACL__HMACAlgorithm;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Security__ACL__Permission {
  /*
   * place holder for backward .proto file compatibility
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__INVALID_PERMISSION = -1,
  /*
   * can read key/values
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__READ = 0,
  /*
   * can write key/values
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__WRITE = 1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__DELETE = 2,
  /*
   * can do a range
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__RANGE = 3,
  /*
   * can set up and a device
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__SETUP = 4,
  /*
   * can do a peer to peer operation
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__P2POP = 5,
  /*
   * can get log
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__GETLOG = 7,
  /*
   * can set up the security roles of the device
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__SECURITY = 8,
  /*
   * can setup power management
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION__POWER_MANAGEMENT = 9
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__PERMISSION)
} Com__Seagate__Kinetic__Proto__Command__Security__ACL__Permission;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Security__SecurityOpType {
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__SECURITY_OP_TYPE__INVALID_SECURITYOP = -1,
  /*
   * This security command is to set up ACL identities
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__SECURITY_OP_TYPE__ACL_SECURITYOP = 1,
  /*
   * This security command is to set the erase pin
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__SECURITY_OP_TYPE__ERASE_PIN_SECURITYOP = 2,
  /*
   * This security command is to set the lock pin
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__SECURITY_OP_TYPE__LOCK_PIN_SECURITYOP = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__SECURITY_OP_TYPE)
} Com__Seagate__Kinetic__Proto__Command__Security__SecurityOpType;
typedef enum _Com__Seagate__Kinetic__Proto__Command__PinOperation__PinOpType {
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE__INVALID_PINOP = -1,
  /*
   * The pin will unlock the device
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE__UNLOCK_PINOP = 1,
  /*
   * This will lock the device. This includes all
   * configuration and user data. This operation is
   * secure from even given physical access and
   * disassembly of the device.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE__LOCK_PINOP = 2,
  /*
   * Erase the device. This may be secure
   * or not. The implication is that it may be faster
   * than the secure operation.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE__ERASE_PINOP = 3,
  /*
   * Erase the device in a way that will
   * physical access and disassembly of the device
   * will not
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE__SECURE_ERASE_PINOP = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__PIN_OP_TYPE)
} Com__Seagate__Kinetic__Proto__Command__PinOperation__PinOpType;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Synchronization {
  /*
   * Must come first, so default is invalid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SYNCHRONIZATION__INVALID_SYNCHRONIZATION = -1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SYNCHRONIZATION__WRITETHROUGH = 1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SYNCHRONIZATION__WRITEBACK = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__SYNCHRONIZATION__FLUSH = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__SYNCHRONIZATION)
} Com__Seagate__Kinetic__Proto__Command__Synchronization;
typedef enum _Com__Seagate__Kinetic__Proto__Command__Priority {
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__NORMAL = 5,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__LOWEST = 1,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__LOWER = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__LOW = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__LOWERNORMAL = 4,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__HIGHERNORMAL = 6,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__HIGH = 7,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__HIGHER = 8,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY__HIGHEST = 9
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__PRIORITY)
} Com__Seagate__Kinetic__Proto__Command__Priority;
/*
 *algorithm
 */
typedef enum _Com__Seagate__Kinetic__Proto__Command__Algorithm {
  /*
   * Must come first, so default is invalid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__INVALID_ALGORITHM = -1,
  /*
   * see NIST
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__SHA1 = 1,
  /*
   * see NIST
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__SHA2 = 2,
  /*
   * see NIST. The length of the tag determined the length of the hash
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__SHA3 = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__CRC32C = 4,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__CRC64 = 5,
  /*
   * 7-99 are reserved.
   * 100-inf are private algorithms.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM__CRC32 = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__ALGORITHM)
} Com__Seagate__Kinetic__Proto__Command__Algorithm;
/*
 *operation code
 */
typedef enum _Com__Seagate__Kinetic__Proto__Command__MessageType {
  /*
   * Must come first, so default is invalid
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__INVALID_MESSAGE_TYPE = -1,
  /*
   *get operation
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GET = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GET_RESPONSE = 1,
  /*
   *put operation
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PUT = 4,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PUT_RESPONSE = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__DELETE = 6,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__DELETE_RESPONSE = 5,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETNEXT = 8,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETNEXT_RESPONSE = 7,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETPREVIOUS = 10,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETPREVIOUS_RESPONSE = 9,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETKEYRANGE = 12,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETKEYRANGE_RESPONSE = 11,
  /*
   * 13 and 14 are reserved, do not use
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETVERSION = 16,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETVERSION_RESPONSE = 15,
  /*
   * 17, 18, 19, and 20 are reserved, do not use
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SETUP = 22,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SETUP_RESPONSE = 21,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETLOG = 24,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__GETLOG_RESPONSE = 23,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SECURITY = 26,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SECURITY_RESPONSE = 25,
  /*
   *peer to peer push operation
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PEER2PEERPUSH = 28,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PEER2PEERPUSH_RESPONSE = 27,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__NOOP = 30,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__NOOP_RESPONSE = 29,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__FLUSHALLDATA = 32,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__FLUSHALLDATA_RESPONSE = 31,
  /*
   * 33, 34 are reserved
   */
  /*
   * Pin based operations
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PINOP = 36,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__PINOP_RESPONSE = 35,
  /*
   * Media scan is to check that the user data is readable, and
   * if the end to end integrity is known to the device, if the
   * end to end integrity field is correct.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__MEDIASCAN = 38,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__MEDIASCAN_RESPONSE = 37,
  /*
   * This performs optimizations of the media. Things like
   * defragmentation, compaction, garbage collection, compression
   * could be things accomplished using the media optimize command.
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__MEDIAOPTIMIZE = 40,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__MEDIAOPTIMIZE_RESPONSE = 39,
  /*
   * batch operations
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__START_BATCH = 42,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__START_BATCH_RESPONSE = 41,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__END_BATCH = 44,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__END_BATCH_RESPONSE = 43,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__ABORT_BATCH = 46,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__ABORT_BATCH_RESPONSE = 45,
  /*
   * power management
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SET_POWER_LEVEL = 48,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE__SET_POWER_LEVEL_RESPONSE = 47
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__MESSAGE_TYPE)
} Com__Seagate__Kinetic__Proto__Command__MessageType;
typedef enum _Com__Seagate__Kinetic__Proto__Command__PowerLevel {
  COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL__INVALID_LEVEL = -1,
  /*
   * Fully operational mode, default mode for the drive
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL__OPERATIONAL = 1,
  /*
   * All operations other than SET_POWER_LEVEL will be rejected
   */
  COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL__HIBERNATE = 2,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL__SHUTDOWN = 3,
  COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL__FAIL = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_LEVEL)
} Com__Seagate__Kinetic__Proto__Command__PowerLevel;

/* --- messages --- */

/*
 * this is a local message to allow the program to read
 * the protocol version number by building this message
 * and then reading the value.
 */
struct  _Com__Seagate__Kinetic__Proto__Local
{
  ProtobufCMessage base;
  char *protocolversion;
};
extern char com__seagate__kinetic__proto__local__protocol_version__default_value[];
#define COM__SEAGATE__KINETIC__PROTO__LOCAL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__local__descriptor) \
    , com__seagate__kinetic__proto__local__protocol_version__default_value }


/*
 * This is for normal message to the device
 * and for responses. These are allowed once the
 * device is unlocked. The HMAC provides for
 * authenticity, Integrity and to enforce roles.
 */
struct  _Com__Seagate__Kinetic__Proto__Message__HMACauth
{
  ProtobufCMessage base;
  /*
   * The "identity" identifies the requester and the key and algorithm to
   * be used for hmac.
   */
  protobuf_c_boolean has_identity;
  int64_t identity;
  protobuf_c_boolean has_hmac;
  ProtobufCBinaryData hmac;
};
#define COM__SEAGATE__KINETIC__PROTO__MESSAGE__HMACAUTH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__message__hmacauth__descriptor) \
    , 0,0, 0,{0,NULL} }


/*
 * Pin based authentication for Pin operations.
 */
struct  _Com__Seagate__Kinetic__Proto__Message__PINauth
{
  ProtobufCMessage base;
  /*
   * The pin necessary to make the operations valid
   */
  protobuf_c_boolean has_pin;
  ProtobufCBinaryData pin;
};
#define COM__SEAGATE__KINETIC__PROTO__MESSAGE__PINAUTH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__message__pinauth__descriptor) \
    , 0,{0,NULL} }


/*
 * THe message is an authorization and command bytes.
 */
struct  _Com__Seagate__Kinetic__Proto__Message
{
  ProtobufCMessage base;
  /*
   * Every message must be one of the following types.
   */
  protobuf_c_boolean has_authtype;
  Com__Seagate__Kinetic__Proto__Message__AuthType authtype;
  /*
   * Normal messages
   */
  Com__Seagate__Kinetic__Proto__Message__HMACauth *hmacauth;
  /*
   * for Pin based operations. These include device unlock and
   * device erase
   */
  Com__Seagate__Kinetic__Proto__Message__PINauth *pinauth;
  /*
   * the embedded message providing the request (for HMACauth) and
   * the response (for all auth types).
   */
  protobuf_c_boolean has_commandbytes;
  ProtobufCBinaryData commandbytes;
};
#define COM__SEAGATE__KINETIC__PROTO__MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__message__descriptor) \
    , 0,0, NULL, NULL, 0,{0,NULL} }


/*
 *message header
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Header
{
  ProtobufCMessage base;
  /*
   * "cluster" is the  number of the cluster definition. If this is incompatible,
   * the request is rejected. By default the value is 0, allowing systems not
   * using cluster versioning to ignore this field in the header and in the setup.
   */
  protobuf_c_boolean has_clusterversion;
  int64_t clusterversion;
  /*
   * A unique number for this connection between the source and target. The device can change this
   * number and the client must continue to use the new number and the number must remain
   * constant during the session.
   */
  protobuf_c_boolean has_connectionid;
  int64_t connectionid;
  /*
   * the sequence of this request in this TCP connection. As long as this value is getting larger we have
   * strong ordering and replay prevention within a session. This combined with the time and connectionID
   * provides strong ordering between sessions.
   */
  protobuf_c_boolean has_sequence;
  uint64_t sequence;
  /*
   *co-related sequence
   */
  protobuf_c_boolean has_acksequence;
  uint64_t acksequence;
  /*
   *operation code - put/get/delete/GetLog, etc.
   */
  protobuf_c_boolean has_messagetype;
  Com__Seagate__Kinetic__Proto__Command__MessageType messagetype;
  /*
   * Request timeout (in ms). This is the amount of time that this request should take. If this timeout
   * is triggered, there are three possible results that can be returned.
   *   - SERVICE_BUSY meaning that the request was still on the queue waiting to be executed
   *   - EXPIRED meaning that a long running operation was stopped because the time expired.
   *   - DATA_ERROR meaning that the request was in process, but that the error recovery was not
   *          complete at the time that the time expired
   */
  protobuf_c_boolean has_timeout;
  uint64_t timeout;
  /*
   * If true, requests will not attempt multi revolution recoveries even if the timeout has not occurred.
   * In this case the result will be DATA_ERROR. To have the device exhaust all possible error recovery, leave
   * this field off or set to false, and make sure that the timeout is set to be longer than any possible queue
   * time and error recovery time. On a disk device, the maximum error recovery time could be seconds.
   * Once all possible data recovery operations are complete and have not succeeded, PERM_DATA_ERROR will be
   * returned.
   */
  protobuf_c_boolean has_earlyexit;
  protobuf_c_boolean earlyexit;
  /*
   * Priority is a simple integer that determines the priority of this
   * request. All activity at a higher priority will execute before that
   * of lower priority traffic. A higher number is higher priority.
   */
  protobuf_c_boolean has_priority;
  Com__Seagate__Kinetic__Proto__Command__Priority priority;
  /*
   * A hint of how long a job should run before yielding. Specified in
   * miliseconds. A value of 0 indicates that the operation can perform one
   * sub operation and then check to see if there are other sub higher
   * priority operations. An example of a sub-operation might be a single put
   * in a P2P operation, etc.
   */
  protobuf_c_boolean has_timequanta;
  uint64_t timequanta;
  /*
   * batch id to be included in each command of a batch operation
   * this id is generated by client library and must be unique
   * within the same connection.
   */
  protobuf_c_boolean has_batchid;
  uint32_t batchid;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__HEADER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__header__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 *message body
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Body
{
  ProtobufCMessage base;
  /*
   *key/value op
   */
  Com__Seagate__Kinetic__Proto__Command__KeyValue *keyvalue;
  /*
   *range operation
   */
  Com__Seagate__Kinetic__Proto__Command__Range *range;
  /*
   *set up operation
   */
  Com__Seagate__Kinetic__Proto__Command__Setup *setup;
  /*
   * Peer to Peer operations.
   */
  Com__Seagate__Kinetic__Proto__Command__P2POperation *p2poperation;
  /*
   *GetLog
   */
  Com__Seagate__Kinetic__Proto__Command__GetLog *getlog;
  /*
   *set up security
   */
  Com__Seagate__Kinetic__Proto__Command__Security *security;
  /*
   * Perform Pin-based operations
   */
  Com__Seagate__Kinetic__Proto__Command__PinOperation *pinop;
  /*
   * batch operation
   * This is included in the END_BATCH and END_BATCH_RESPONSE.
   */
  Com__Seagate__Kinetic__Proto__Command__Batch *batch;
  /*
   * power management
   */
  Com__Seagate__Kinetic__Proto__Command__PowerManagement *power;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__body__descriptor) \
    , NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }


struct  _Com__Seagate__Kinetic__Proto__Command__PowerManagement
{
  ProtobufCMessage base;
  protobuf_c_boolean has_level;
  Com__Seagate__Kinetic__Proto__Command__PowerLevel level;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__POWER_MANAGEMENT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__power_management__descriptor) \
    , 0,0 }


/*
 * This is included in the END_BATCH and END_BATCH_RESPONSE.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Batch
{
  ProtobufCMessage base;
  /*
   * set by the client library in END_BATCH request message.
   * the total number of operations in the batch
   */
  protobuf_c_boolean has_count;
  uint32_t count;
  /*
   * set by the drive in END_BATCH_RESPONSE message.
   * If a batch is committed successfully, all sequence Ids of those
   * commands (PUT/DELETE) performed in the batch are
   * added in the END_BATCH_RESPONSE message.
   */
  size_t n_sequence;
  uint64_t *sequence;
  /*
   * This field is set by the drive if a batch commit failed.
   * The sequence of the first operation to fail in the batch.
   * There is no guarantee that the previous sequences would have succeeded.
   */
  protobuf_c_boolean has_failedsequence;
  uint64_t failedsequence;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__BATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__batch__descriptor) \
    , 0,0, 0,NULL, 0,0 }


/*
 *operation status
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Status
{
  ProtobufCMessage base;
  /*
   *status code
   */
  protobuf_c_boolean has_code;
  Com__Seagate__Kinetic__Proto__Command__Status__StatusCode code;
  /*
   *status message
   */
  char *statusmessage;
  /*
   *optional information comes with status
   */
  protobuf_c_boolean has_detailedmessage;
  ProtobufCBinaryData detailedmessage;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__STATUS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__status__descriptor) \
    , 0,0, NULL, 0,{0,NULL} }


/*
 *key/value entry operation
 */
struct  _Com__Seagate__Kinetic__Proto__Command__KeyValue
{
  ProtobufCMessage base;
  /*
   * On a put, this is the next version that the data will be. The version field is opaque to the target.
   */
  protobuf_c_boolean has_newversion;
  ProtobufCBinaryData newversion;
  /*
   * If set to True, puts will ignore any existing version (if it exists), and deletes will ignore
   * any existing version or if the key is not found (allowing a success on the delete of a non-existent key).
   */
  protobuf_c_boolean has_force;
  protobuf_c_boolean force;
  /*
   *entry key
   */
  protobuf_c_boolean has_key;
  ProtobufCBinaryData key;
  /*
   *entry version in store
   */
  protobuf_c_boolean has_dbversion;
  ProtobufCBinaryData dbversion;
  /*
   * this is the integrity value of the data. This may or may not be in the clear, depending on the algorithm
   * used.
   */
  protobuf_c_boolean has_tag;
  ProtobufCBinaryData tag;
  /*
   * The following is for the protection of the data. If the data is protected with a hash or CRC, then
   * the algorithm will be negative. If the data protection algorithm is not a standard unkeyed algorithm
   * then  a positive number is used and the device has no idea what the key is.
   */
  protobuf_c_boolean has_algorithm;
  Com__Seagate__Kinetic__Proto__Command__Algorithm algorithm;
  /*
   * for read operations, this will get all the information about the value except for the
   * value itself. This is valuable for getting the integrity field or the version without also
   * having to get the data.
   */
  protobuf_c_boolean has_metadataonly;
  protobuf_c_boolean metadataonly;
  /*
   * Synchronization allows the puts and deletes to determine if they are to be
   * WRITETHROUGH: This request is made persistent before returning. This does not effect any other pending operations.
   * WRITEBACK: They can be made persistent when the device chooses, or when a subsequent FLUSH is give to the device.
   * FLUSH: All pending information that has not been written is pushed to the disk and the command that
   *    specifies FLUSH is written last and then returned. All WRITEBACK writes that have received ending
   *    status will be guaranteed to be written before the FLUSH operation is returned completed.
   */
  protobuf_c_boolean has_synchronization;
  Com__Seagate__Kinetic__Proto__Command__Synchronization synchronization;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__KEY_VALUE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__key_value__descriptor) \
    , 0,{0,NULL}, 0,0, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,0, 0,0 }


/*
 *key range op
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Range
{
  ProtobufCMessage base;
  protobuf_c_boolean has_startkey;
  ProtobufCBinaryData startkey;
  protobuf_c_boolean has_endkey;
  ProtobufCBinaryData endkey;
  protobuf_c_boolean has_startkeyinclusive;
  protobuf_c_boolean startkeyinclusive;
  protobuf_c_boolean has_endkeyinclusive;
  protobuf_c_boolean endkeyinclusive;
  /*
   * The maximum number of keys returned
   */
  protobuf_c_boolean has_maxreturned;
  uint32_t maxreturned;
  /*
   * The keys are searched for and returned in a reverse order. For instance
   * if the search is startKey="j", endKey="k", maxReturned=2,
   * reverse=true and the keys "k0", "k1", "k2" exist
   * the system will return "k2" and "k1" in that order.
   */
  protobuf_c_boolean has_reverse;
  protobuf_c_boolean reverse;
  /*
   *get range response .
   */
  size_t n_keys;
  ProtobufCBinaryData *keys;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__range__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,0, 0,0, 0,0, 0,NULL }


/*
 * These are persistent options that are retained across power fail and
 * erased on either PIN erase or PIN secure erase.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Setup
{
  ProtobufCMessage base;
  /*
   * The cluster version to be checked. The default if never set is 0.
   * This is persistent between boots of the device.
   */
  protobuf_c_boolean has_newclusterversion;
  int64_t newclusterversion;
  /*
   * Indicate the purpose of this message, tells the device what fields are relevent
   */
  protobuf_c_boolean has_setupoptype;
  Com__Seagate__Kinetic__Proto__Command__Setup__SetupOpType setupoptype;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__SETUP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__setup__descriptor) \
    , 0,0, 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation
{
  ProtobufCMessage base;
  /*
   * the key of the entry to move
   */
  protobuf_c_boolean has_key;
  ProtobufCBinaryData key;
  /*
   * the expected version number in the other machine
   * the version number will be the version in the stored entry.
   */
  protobuf_c_boolean has_version;
  ProtobufCBinaryData version;
  /*
   * to have the moved key have a different final key used.
   */
  protobuf_c_boolean has_newkey;
  ProtobufCBinaryData newkey;
  /*
   * force the write ignoring the current key version.
   */
  protobuf_c_boolean has_force;
  protobuf_c_boolean force;
  /*
   * returned status
   */
  Com__Seagate__Kinetic__Proto__Command__Status *status;
  /*
   * an operation to add to this put operation. THis allows the
   * formation of a pipeline client -> A ->B ->C with the status for all returning
   * back to the client.
   */
  Com__Seagate__Kinetic__Proto__Command__P2POperation *p2pop;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__P2_POPERATION__OPERATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__p2_poperation__operation__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,0, NULL, NULL }


struct  _Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer
{
  ProtobufCMessage base;
  char *hostname;
  protobuf_c_boolean has_port;
  uint32_t port;
  protobuf_c_boolean has_tls;
  protobuf_c_boolean tls;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__P2_POPERATION__PEER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__p2_poperation__peer__descriptor) \
    , NULL, 0,0, 0,0 }


/*
 * P2P operations allow devices to be able to send keys to other devices.
 * this is either a standalone command or added to a put command.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__P2POperation
{
  ProtobufCMessage base;
  /*
   * Describe the target machine
   */
  Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer *peer;
  /*
   * List of operations to be performed.
   */
  size_t n_operation;
  Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation **operation;
  /*
   * Indicates whether all operations have Status SUCCESS
   * When false, clients should traverse Operation status codes to discover
   * error cases.
   * When true, no further error checking should be required.
   */
  protobuf_c_boolean has_allchildoperationssucceeded;
  protobuf_c_boolean allchildoperationssucceeded;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__P2_POPERATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__p2_poperation__descriptor) \
    , NULL, 0,NULL, 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization
{
  ProtobufCMessage base;
  /*
   * The name of the utilization being reported. These names can be standard and proprietary. The
   * standard names are "HDA", "EN0" and "EN1". If there are more items that are
   * being reported, such as processor utilization, can have a descriptive name.
   */
  char *name;
  /*
   * A number between 0.00 and 1.00. The resolution of this number is up to the
   * device. 1 means 100% utilized.
   */
  protobuf_c_boolean has_value;
  float value;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__UTILIZATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__utilization__descriptor) \
    , NULL, 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature
{
  ProtobufCMessage base;
  /*
   * The name of the temperature being reported. These names can be standard and proprietary. The
   * standard name is "HDA". If there are more items that are
   * being reported, such as processor temperature, can have a descriptive name.
   */
  char *name;
  /*
   * The current temperature in degrees c
   */
  protobuf_c_boolean has_current;
  float current;
  protobuf_c_boolean has_minimum;
  float minimum;
  protobuf_c_boolean has_maximum;
  float maximum;
  protobuf_c_boolean has_target;
  float target;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__TEMPERATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__temperature__descriptor) \
    , NULL, 0,0, 0,0, 0,0, 0,0 }


/*
 * These capacities are in bytes.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity
{
  ProtobufCMessage base;
  /*
   * 1-3 are reserved
   */
  protobuf_c_boolean has_nominalcapacityinbytes;
  uint64_t nominalcapacityinbytes;
  protobuf_c_boolean has_portionfull;
  float portionfull;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__CAPACITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__capacity__descriptor) \
    , 0,0, 0,0 }


/*
 * 18, 19 are reserved.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface
{
  ProtobufCMessage base;
  char *name;
  protobuf_c_boolean has_mac;
  ProtobufCBinaryData mac;
  protobuf_c_boolean has_ipv4address;
  ProtobufCBinaryData ipv4address;
  protobuf_c_boolean has_ipv6address;
  ProtobufCBinaryData ipv6address;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__CONFIGURATION__INTERFACE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__configuration__interface__descriptor) \
    , NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL} }


struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration
{
  ProtobufCMessage base;
  /*
   * name of the vendor.
   */
  char *vendor;
  /*
   * The model of the device.
   * "Simulator" for the simulator.
   */
  char *model;
  /*
   * Device Serial number (SN)
   */
  protobuf_c_boolean has_serialnumber;
  ProtobufCBinaryData serialnumber;
  /*
   * Device world wide name (WWN)
   */
  protobuf_c_boolean has_worldwidename;
  ProtobufCBinaryData worldwidename;
  /*
   * This is the vendor specific version of the software on the device in dot notation
   */
  char *version;
  char *compilationdate;
  char *sourcehash;
  /*
   * This is the version of the protocol (.proto file) that the device uses.
   * This is not the highest or lowest version that is supported, just
   * the version that was compiled.
   */
  char *protocolversion;
  char *protocolcompilationdate;
  char *protocolsourcehash;
  /*
   * the interfaces for this device. one per interface.
   */
  size_t n_interface;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface **interface;
  /*
   * these are the port numbers for the software
   */
  protobuf_c_boolean has_port;
  uint32_t port;
  protobuf_c_boolean has_tlsport;
  uint32_t tlsport;
  /*
   * The unsolicited message at the beginning of a connection will return
   * the drive status. The only two possible values are OPERATIONAL
   * or HIBERNATE.
   */
  protobuf_c_boolean has_currentpowerlevel;
  Com__Seagate__Kinetic__Proto__Command__PowerLevel currentpowerlevel;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__configuration__descriptor) \
    , NULL, NULL, 0,{0,NULL}, 0,{0,NULL}, NULL, NULL, NULL, NULL, NULL, NULL, 0,NULL, 0,0, 0,0, 0,0 }


/*
 * These numbers start at 0 when the device starts up and never wraps or resets.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics
{
  ProtobufCMessage base;
  protobuf_c_boolean has_messagetype;
  Com__Seagate__Kinetic__Proto__Command__MessageType messagetype;
  /*
   * 2 and 3 are reserved, do not use
   */
  protobuf_c_boolean has_count;
  uint64_t count;
  /*
   * This is the sum of the data that is in the data portion. This does not include t
   * the command description. For P2P operations, this is the amount of data moved between
   * devices
   */
  protobuf_c_boolean has_bytes;
  uint64_t bytes;
  /*
   *reports max response time for each operation in ms
   */
  protobuf_c_boolean has_maxlatency;
  uint64_t maxlatency;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__STATISTICS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__statistics__descriptor) \
    , 0,0, 0,0, 0,0, 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Limits
{
  ProtobufCMessage base;
  protobuf_c_boolean has_maxkeysize;
  uint32_t maxkeysize;
  protobuf_c_boolean has_maxvaluesize;
  uint32_t maxvaluesize;
  protobuf_c_boolean has_maxversionsize;
  uint32_t maxversionsize;
  protobuf_c_boolean has_maxtagsize;
  uint32_t maxtagsize;
  protobuf_c_boolean has_maxconnections;
  uint32_t maxconnections;
  protobuf_c_boolean has_maxoutstandingreadrequests;
  uint32_t maxoutstandingreadrequests;
  protobuf_c_boolean has_maxoutstandingwriterequests;
  uint32_t maxoutstandingwriterequests;
  protobuf_c_boolean has_maxmessagesize;
  uint32_t maxmessagesize;
  protobuf_c_boolean has_maxkeyrangecount;
  uint32_t maxkeyrangecount;
  protobuf_c_boolean has_maxidentitycount;
  uint32_t maxidentitycount;
  protobuf_c_boolean has_maxpinsize;
  uint32_t maxpinsize;
  protobuf_c_boolean has_maxoperationcountperbatch;
  uint32_t maxoperationcountperbatch;
  protobuf_c_boolean has_maxbatchcountperdevice;
  uint32_t maxbatchcountperdevice;
  protobuf_c_boolean has_maxbatchsize;
  uint32_t maxbatchsize;
  protobuf_c_boolean has_maxdeletesperbatch;
  uint32_t maxdeletesperbatch;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__LIMITS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__limits__descriptor) \
    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }


/*
 * The Device GetLog message is to ask the device to send back the
 * log of a certain name in the value field. The limit of each
 * log is 1m byte.
 * Proprietary names should be prefaced by the vendor name so that name
 * collisions do not happen in the future. An example could be names that
 * start with “com.WD” would be for Western Digital devices.
 * If the name is not found, the get log returns NOT_FOUND.
 * There can be only one Device in the list of logs that can be retrieved.!
 */
struct  _Com__Seagate__Kinetic__Proto__Command__GetLog__Device
{
  ProtobufCMessage base;
  protobuf_c_boolean has_name;
  ProtobufCBinaryData name;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__DEVICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__device__descriptor) \
    , 0,{0,NULL} }


/*
 *get log
 */
struct  _Com__Seagate__Kinetic__Proto__Command__GetLog
{
  ProtobufCMessage base;
  size_t n_types;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Type *types;
  size_t n_utilizations;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization **utilizations;
  size_t n_temperatures;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature **temperatures;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity *capacity;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration *configuration;
  size_t n_statistics;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics **statistics;
  protobuf_c_boolean has_messages;
  ProtobufCBinaryData messages;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Limits *limits;
  Com__Seagate__Kinetic__Proto__Command__GetLog__Device *device;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__GET_LOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__get_log__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, NULL, NULL, 0,NULL, 0,{0,NULL}, NULL, NULL }


struct  _Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope
{
  ProtobufCMessage base;
  protobuf_c_boolean has_offset;
  uint64_t offset;
  protobuf_c_boolean has_value;
  ProtobufCBinaryData value;
  size_t n_permission;
  Com__Seagate__Kinetic__Proto__Command__Security__ACL__Permission *permission;
  /*
   * This is only allowed over the the TLS connection
   */
  protobuf_c_boolean has_tlsrequired;
  protobuf_c_boolean tlsrequired;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__SCOPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__security__acl__scope__descriptor) \
    , 0,0, 0,{0,NULL}, 0,NULL, 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command__Security__ACL
{
  ProtobufCMessage base;
  protobuf_c_boolean has_identity;
  int64_t identity;
  /*
   * the HMAC key
   */
  protobuf_c_boolean has_key;
  ProtobufCBinaryData key;
  protobuf_c_boolean has_hmacalgorithm;
  Com__Seagate__Kinetic__Proto__Command__Security__ACL__HMACAlgorithm hmacalgorithm;
  /*
   * value that must be in the key for read, write, range requests. If none are specified
   * then no checking occurs. If one or more is specified, one must match or the request
   * is rejected
   */
  size_t n_scope;
  Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope **scope;
  /*
   * The maxPriority is checked against the header priority field. The header priority
   * for any command must be less than or equal to this maxPriority field.
   */
  protobuf_c_boolean has_maxpriority;
  Com__Seagate__Kinetic__Proto__Command__Priority maxpriority;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__ACL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__security__acl__descriptor) \
    , 0,0, 0,{0,NULL}, 0,0, 0,NULL, 0,0 }


/*
 * These are persistent options that are retained across power fail and
 * erased on either PIN erase or PIN secure erase.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__Security
{
  ProtobufCMessage base;
  /*
   * one per identity
   */
  size_t n_acl;
  Com__Seagate__Kinetic__Proto__Command__Security__ACL **acl;
  /*
   * Set the lock and erase pins.
   */
  protobuf_c_boolean has_oldlockpin;
  ProtobufCBinaryData oldlockpin;
  protobuf_c_boolean has_newlockpin;
  ProtobufCBinaryData newlockpin;
  protobuf_c_boolean has_olderasepin;
  ProtobufCBinaryData olderasepin;
  protobuf_c_boolean has_newerasepin;
  ProtobufCBinaryData newerasepin;
  protobuf_c_boolean has_securityoptype;
  Com__Seagate__Kinetic__Proto__Command__Security__SecurityOpType securityoptype;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__SECURITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__security__descriptor) \
    , 0,NULL, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,{0,NULL}, 0,0 }


/*
 * Pin Operations are used for special commands that are valid when the device
 * is locked or to be locked. These are unlock, lock and erase.
 * This must come over the TLS connection to protect the confidentiality and
 * integrity. This operations must be used with PinAuth.
 */
struct  _Com__Seagate__Kinetic__Proto__Command__PinOperation
{
  ProtobufCMessage base;
  protobuf_c_boolean has_pinoptype;
  Com__Seagate__Kinetic__Proto__Command__PinOperation__PinOpType pinoptype;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__PIN_OPERATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__pin_operation__descriptor) \
    , 0,0 }


struct  _Com__Seagate__Kinetic__Proto__Command
{
  ProtobufCMessage base;
  /*
   *message header
   */
  Com__Seagate__Kinetic__Proto__Command__Header *header;
  /*
   *message body
   */
  Com__Seagate__Kinetic__Proto__Command__Body *body;
  /*
   *operation status
   */
  Com__Seagate__Kinetic__Proto__Command__Status *status;
};
#define COM__SEAGATE__KINETIC__PROTO__COMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&com__seagate__kinetic__proto__command__descriptor) \
    , NULL, NULL, NULL }


/* Com__Seagate__Kinetic__Proto__Local methods */
void   com__seagate__kinetic__proto__local__init
                     (Com__Seagate__Kinetic__Proto__Local         *message);
size_t com__seagate__kinetic__proto__local__get_packed_size
                     (const Com__Seagate__Kinetic__Proto__Local   *message);
size_t com__seagate__kinetic__proto__local__pack
                     (const Com__Seagate__Kinetic__Proto__Local   *message,
                      uint8_t             *out);
size_t com__seagate__kinetic__proto__local__pack_to_buffer
                     (const Com__Seagate__Kinetic__Proto__Local   *message,
                      ProtobufCBuffer     *buffer);
Com__Seagate__Kinetic__Proto__Local *
       com__seagate__kinetic__proto__local__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   com__seagate__kinetic__proto__local__free_unpacked
                     (Com__Seagate__Kinetic__Proto__Local *message,
                      ProtobufCAllocator *allocator);
/* Com__Seagate__Kinetic__Proto__Message__HMACauth methods */
void   com__seagate__kinetic__proto__message__hmacauth__init
                     (Com__Seagate__Kinetic__Proto__Message__HMACauth         *message);
/* Com__Seagate__Kinetic__Proto__Message__PINauth methods */
void   com__seagate__kinetic__proto__message__pinauth__init
                     (Com__Seagate__Kinetic__Proto__Message__PINauth         *message);
/* Com__Seagate__Kinetic__Proto__Message methods */
void   com__seagate__kinetic__proto__message__init
                     (Com__Seagate__Kinetic__Proto__Message         *message);
size_t com__seagate__kinetic__proto__message__get_packed_size
                     (const Com__Seagate__Kinetic__Proto__Message   *message);
size_t com__seagate__kinetic__proto__message__pack
                     (const Com__Seagate__Kinetic__Proto__Message   *message,
                      uint8_t             *out);
size_t com__seagate__kinetic__proto__message__pack_to_buffer
                     (const Com__Seagate__Kinetic__Proto__Message   *message,
                      ProtobufCBuffer     *buffer);
Com__Seagate__Kinetic__Proto__Message *
       com__seagate__kinetic__proto__message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   com__seagate__kinetic__proto__message__free_unpacked
                     (Com__Seagate__Kinetic__Proto__Message *message,
                      ProtobufCAllocator *allocator);
/* Com__Seagate__Kinetic__Proto__Command__Header methods */
void   com__seagate__kinetic__proto__command__header__init
                     (Com__Seagate__Kinetic__Proto__Command__Header         *message);
/* Com__Seagate__Kinetic__Proto__Command__Body methods */
void   com__seagate__kinetic__proto__command__body__init
                     (Com__Seagate__Kinetic__Proto__Command__Body         *message);
/* Com__Seagate__Kinetic__Proto__Command__PowerManagement methods */
void   com__seagate__kinetic__proto__command__power_management__init
                     (Com__Seagate__Kinetic__Proto__Command__PowerManagement         *message);
/* Com__Seagate__Kinetic__Proto__Command__Batch methods */
void   com__seagate__kinetic__proto__command__batch__init
                     (Com__Seagate__Kinetic__Proto__Command__Batch         *message);
/* Com__Seagate__Kinetic__Proto__Command__Status methods */
void   com__seagate__kinetic__proto__command__status__init
                     (Com__Seagate__Kinetic__Proto__Command__Status         *message);
/* Com__Seagate__Kinetic__Proto__Command__KeyValue methods */
void   com__seagate__kinetic__proto__command__key_value__init
                     (Com__Seagate__Kinetic__Proto__Command__KeyValue         *message);
/* Com__Seagate__Kinetic__Proto__Command__Range methods */
void   com__seagate__kinetic__proto__command__range__init
                     (Com__Seagate__Kinetic__Proto__Command__Range         *message);
/* Com__Seagate__Kinetic__Proto__Command__Setup methods */
void   com__seagate__kinetic__proto__command__setup__init
                     (Com__Seagate__Kinetic__Proto__Command__Setup         *message);
/* Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation methods */
void   com__seagate__kinetic__proto__command__p2_poperation__operation__init
                     (Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation         *message);
/* Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer methods */
void   com__seagate__kinetic__proto__command__p2_poperation__peer__init
                     (Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer         *message);
/* Com__Seagate__Kinetic__Proto__Command__P2POperation methods */
void   com__seagate__kinetic__proto__command__p2_poperation__init
                     (Com__Seagate__Kinetic__Proto__Command__P2POperation         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization methods */
void   com__seagate__kinetic__proto__command__get_log__utilization__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature methods */
void   com__seagate__kinetic__proto__command__get_log__temperature__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity methods */
void   com__seagate__kinetic__proto__command__get_log__capacity__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface methods */
void   com__seagate__kinetic__proto__command__get_log__configuration__interface__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration methods */
void   com__seagate__kinetic__proto__command__get_log__configuration__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics methods */
void   com__seagate__kinetic__proto__command__get_log__statistics__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Limits methods */
void   com__seagate__kinetic__proto__command__get_log__limits__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Limits         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog__Device methods */
void   com__seagate__kinetic__proto__command__get_log__device__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog__Device         *message);
/* Com__Seagate__Kinetic__Proto__Command__GetLog methods */
void   com__seagate__kinetic__proto__command__get_log__init
                     (Com__Seagate__Kinetic__Proto__Command__GetLog         *message);
/* Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope methods */
void   com__seagate__kinetic__proto__command__security__acl__scope__init
                     (Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope         *message);
/* Com__Seagate__Kinetic__Proto__Command__Security__ACL methods */
void   com__seagate__kinetic__proto__command__security__acl__init
                     (Com__Seagate__Kinetic__Proto__Command__Security__ACL         *message);
/* Com__Seagate__Kinetic__Proto__Command__Security methods */
void   com__seagate__kinetic__proto__command__security__init
                     (Com__Seagate__Kinetic__Proto__Command__Security         *message);
/* Com__Seagate__Kinetic__Proto__Command__PinOperation methods */
void   com__seagate__kinetic__proto__command__pin_operation__init
                     (Com__Seagate__Kinetic__Proto__Command__PinOperation         *message);
/* Com__Seagate__Kinetic__Proto__Command methods */
void   com__seagate__kinetic__proto__command__init
                     (Com__Seagate__Kinetic__Proto__Command         *message);
size_t com__seagate__kinetic__proto__command__get_packed_size
                     (const Com__Seagate__Kinetic__Proto__Command   *message);
size_t com__seagate__kinetic__proto__command__pack
                     (const Com__Seagate__Kinetic__Proto__Command   *message,
                      uint8_t             *out);
size_t com__seagate__kinetic__proto__command__pack_to_buffer
                     (const Com__Seagate__Kinetic__Proto__Command   *message,
                      ProtobufCBuffer     *buffer);
Com__Seagate__Kinetic__Proto__Command *
       com__seagate__kinetic__proto__command__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   com__seagate__kinetic__proto__command__free_unpacked
                     (Com__Seagate__Kinetic__Proto__Command *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Com__Seagate__Kinetic__Proto__Local_Closure)
                 (const Com__Seagate__Kinetic__Proto__Local *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Message__HMACauth_Closure)
                 (const Com__Seagate__Kinetic__Proto__Message__HMACauth *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Message__PINauth_Closure)
                 (const Com__Seagate__Kinetic__Proto__Message__PINauth *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Message_Closure)
                 (const Com__Seagate__Kinetic__Proto__Message *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Header_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Header *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Body_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Body *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__PowerManagement_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__PowerManagement *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Batch_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Batch *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Status_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Status *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__KeyValue_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__KeyValue *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Range_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Range *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Setup_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Setup *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__P2POperation__Operation *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__P2POperation__Peer *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__P2POperation_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__P2POperation *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Utilization *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Temperature *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Capacity *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration__Interface *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Configuration *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Statistics *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Limits_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Limits *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog__Device_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog__Device *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__GetLog_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__GetLog *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Security__ACL__Scope *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Security__ACL_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Security__ACL *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__Security_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__Security *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command__PinOperation_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command__PinOperation *message,
                  void *closure_data);
typedef void (*Com__Seagate__Kinetic__Proto__Command_Closure)
                 (const Com__Seagate__Kinetic__Proto__Command *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__local__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__message__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__message__hmacauth__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__message__pinauth__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__message__auth_type__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__header__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__body__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__power_management__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__batch__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__status__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__status__status_code__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__key_value__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__range__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__setup__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__setup__setup_op_type__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__p2_poperation__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__p2_poperation__operation__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__p2_poperation__peer__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__utilization__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__temperature__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__capacity__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__configuration__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__configuration__interface__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__statistics__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__limits__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__get_log__device__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__get_log__type__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__security__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__security__acl__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__security__acl__scope__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__security__acl__hmacalgorithm__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__security__acl__permission__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__security__security_op_type__descriptor;
extern const ProtobufCMessageDescriptor com__seagate__kinetic__proto__command__pin_operation__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__pin_operation__pin_op_type__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__synchronization__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__priority__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__algorithm__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__message_type__descriptor;
extern const ProtobufCEnumDescriptor    com__seagate__kinetic__proto__command__power_level__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_kinetic_2eproto__INCLUDED */
