/**
 * Copyright 2020-2021 Seagate Technology LLC.
 *
 * This Source Code Form is subject to the terms of the Mozilla
 * Public License, v. 2.0. If a copy of the MPL was not
 * distributed with this file, You can obtain one at
 * https://mozilla.org/MP:/2.0/.
 *
 * This program is distributed in the hope that it will be useful,
 * but is provided AS-IS, WITHOUT ANY WARRANTY; including without
 * the implied warranty of MERCHANTABILITY, NON-INFRINGEMENT or
 * FITNESS FOR A PARTICULAR PURPOSE. See the Mozilla Public
 * License for more details.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/types.h>

#include "basickv.h"

#define BKV_N_MAXKEYS 256
#define BKV_N_MAXKEYS_DIGITS 3	
/* Include the dot ".256" */
#define BKV_N_MAXKEYS_FORMAT ".%03d"	


int
bkv_open(bkvs_open_t *bkvo)
{
	int ktd;
	
	ktd = ki_open(bkvo->bkvo_host, bkvo->bkvo_port,
		      bkvo->bkvo_usetls,
		      bkvo->bkvo_id, bkvo->bkvo_pass);
	
	if (ktd < 0) {
		debug_fprintf("bkv_open: Connection Failed\n");
		return(-1);
	}

	return(ktd);
}


int
bkv_close(int ktd)
{
	ki_close(ktd);
	return(0);
}


int
bkv_limits(int ktd, bkv_limits_t *l)
{
	klimits_t kil;
	
	if (!l) {
		debug_fprintf("bkv_limits: Bad limits param\n");
		return(-1);
	}
		
	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_limits: Unable to get kinetic limits\n");
		return(-1);
	}

	l->bkvl_klen = kil.kl_keylen;
	l->bkvl_vlen = kil.kl_vallen;
	l->bkvl_maxn = BKV_N_MAXKEYS;

	return(0);
}


int
bkv_get(int ktd, void *key, size_t klen, void **val, size_t *vlen)
{
	kv_t		*kv;
	struct kiovec	kv_key[1]  = {{0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};
	klimits_t	kil;
	kstatus_t 	kstatus;

	if (!key || !klen || !val || !vlen) {
		debug_fprintf("bkv_get: Illegal arguments\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_get: Unable to get kinetic limits\n");
		return(-1);
	}

	if (klen > kil.kl_keylen) {
		debug_fprintf("bkv_get: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_get: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 1;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/*
	 * Hang the key
	 */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;

	kstatus = ki_get(ktd, kv);

	switch (kstatus) {
	case K_OK:
		*val  = kv->kv_val[0].kiov_base;
		*vlen = kv->kv_val[0].kiov_len;
		break;
	case K_ENOTFOUND:
		debug_fprintf("bkv_get: No key found.\n");
		return(-1);
	default:	
		debug_fprintf("bkv_get: failed: status code %d\n", kstatus);
		return(-1);
	}
	
	return(0);
}


/*
 * Get n keys and concat the value into a single buffer, keys are
 * generated by appending zero paded index to the basekey.
 * e.g. key="key" n=3, getn will get keys: "key.001" "key.002" "key.003"
 * n is limited to BKV_N_MAXKEYS keys
 */
int
bkv_getn(int ktd, void *key, size_t klen, uint32_t n, void **val, size_t *vlen)
{
	int		i;
	char 		*p, nkey[BKV_N_MAXKEYS_DIGITS + 2];
	void 		**ival = NULL;
	size_t 		*ivlen = NULL;
	kstatus_t 	kstatus;
	kv_t		*kv = NULL;
	klimits_t	kil;
	struct kiovec	kv_key[2]  = {{0, 0}, {0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};

	if (!key || !klen || !n || !val || !vlen) {
		debug_fprintf("bkv_getn: Illegal arguments\n");
		return(-1);
	}

	if (n > BKV_N_MAXKEYS) {
		debug_fprintf("bkv_getn: Too many keys requested\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_getn: Unable to get kinetic limits\n");
		return(-1);
	}

	/* klen + ".000" */
	if ((klen + 1 + BKV_N_MAXKEYS_DIGITS) > kil.kl_keylen) {
		debug_fprintf("bkv_getn: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_getn: No Mem\n");
		return(-1);
	}

	/* 
	 * Allocate the value and value length arrays. Also the string for the
	 * generated key. These are internal structures and not part of the 
	 * BPF prog so these allocations can be outside the BPF address space.
	 * So using std heap. 
	 */
	ival  = calloc(n, sizeof(void *));
	ivlen = calloc(n, sizeof(size_t));
	if (!ival || !ivlen) {
		debug_fprintf("bkv_getn: No array memory\n");
		goto getn_out;
	}
	memset(ival, 0, n * sizeof(void *));
	memset(ivlen, 0, n * sizeof(size_t));
	
	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 2;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/* Hang the key buffers: key then suffix */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;
	
	kv->kv_key[1].kiov_base = nkey;
	kv->kv_key[1].kiov_len  = BKV_N_MAXKEYS_DIGITS + 1;

	/* Loop through the key space getting the values */
	*vlen = 0;
	for (i=0;i<n;i++) {

		/* Generate the suffix, start at 0, e.g. ".000" */
		sprintf(nkey, BKV_N_MAXKEYS_FORMAT, i);
		
		kstatus = ki_get(ktd, kv);
		if (kstatus != K_OK) {
			debug_fprintf("bkv_getn: Failed\n");
			goto getn_out;
		}

		/* hang the value buffer */
		ival[i] = kv->kv_val[0].kiov_base;
		ivlen[i] = kv->kv_val[0].kiov_len;
		
		/* update the total value space required length */
		*vlen += ivlen[i];

		ki_clean(kv);
	}

	/* Get a single buffer in the protected BPF address space */
	*val = malloc(*vlen);
	if (!*val) {
		debug_fprintf("bkv_getn: No memory\n");
		goto getn_out;
	}

	/* Copy/Concatenate values to the protected BPF address space */
	p=*val;
	for (i=0;i<n;i++) {
		//printf("Copy %p:%p:%lx -> %.25s]\n", p, ival[i], ivlen[i],
		//       (char *)ival[i]); 
		memcpy(p, ival[i], ivlen[i]);
		p = p + ivlen[i];
		free(ival[i]);
	}

	if (kv) ki_destroy(kv);
	if (ival)  free(ival);
	if (ivlen) free(ivlen);

	return(n);

 getn_out:
	if (kv) ki_destroy(kv);

	if (ival) {
		/* Free any partial value buffers */
		for (i=0;i<n;i++) {
			if (ival[i])
				free(ival[i]);
		}
		free(ival);
	}
	if (ivlen) free(ivlen);

	*val  = NULL;
	*vlen = 0;
	return(-1);
}


int
bkv_put(int ktd, void *key, size_t klen, void  *val, size_t vlen)
{
	uint32_t	sum=0;
	kv_t		*kv;
	struct kiovec	kv_key[1]  = {{0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};
	klimits_t	kil;
	kstatus_t 	kstatus;

	if (!key || !klen || !val || !vlen) {
		debug_fprintf("bkv_put: Illegal arguments\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_put: Unable to get kinetic limits\n");
		return(-1);
	}

	if (klen > kil.kl_keylen) {
		debug_fprintf("bkv_put: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_put: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 1;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/*
	 * Hang the key and value
	 */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;
	kv->kv_val[0].kiov_base = val;
	kv->kv_val[0].kiov_len  = vlen;

	/* PAK:FIXME Version and DI not used. */
	kv->kv_newver = "000000000";
	kv->kv_newverlen = 8;
	kv->kv_disum = &sum;
	kv->kv_disumlen = sizeof(sum);
	kv->kv_ditype = KDI_CRC32;
	kv->kv_cpolicy = KC_WT;	

	kstatus = ki_put(ktd, NULL, kv);
	
	if(kstatus != K_OK) {
		debug_fprintf("bkv_put kinetic: failed: status code %d\n", k
			      status);
		return(-1);
	}
	
	return(0);
}


/*
 * Break up a single large value buffer into n keys and n puts, n is
 * is derived by breaking the value buffer into the largest legal value lens.
 * Keys are generated by appending zero paded index to the basekey.
 * e.g. key="key" n=3, putn will put keys: "key.001" "key.002" "key.003"
 * n is limited to BKV_N_MAXKEYS keys and therefore value sizes are limited
 * to BKV_N_MAXKEYS * kil.kl_vallen
 */
int
bkv_putn(int ktd, void *key, size_t klen, uint32_t *n, void  *val, size_t vlen)
{
	int		i;
	uint32_t	sum=0;
	void 		*pval;
	char		nkey[BKV_N_MAXKEYS_DIGITS + 2];
	size_t 		pvlen;
	klimits_t	kil;
	kstatus_t 	kstatus;
	kv_t		*kv;
	struct kiovec	kv_key[2]  = {{0, 0}, {0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};

	if (!key || !klen || !n || !val || !vlen) {
		debug_fprintf("bkv_putn: Illegal arguments\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_putn: Unable to get kinetic limits\n");
		return(-1);
	}

	/* check the full keylen: klen + ".000" */
	if ((klen + 1 + BKV_N_MAXKEYS_DIGITS) > kil.kl_keylen) {
		debug_fprintf("bkv_putn: Illegal key length\n");
		return(-1);
	}

	/* How many keys is this request going to generate? */
	*n = (vlen / kil.kl_vallen) + (vlen % kil.kl_vallen?1:0);
	if (*n > BKV_N_MAXKEYS) {
		debug_fprintf("bkv_putn: Value requires too many keys\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_putn: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 2;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/* Hang the key buffers: key then suffix */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;
	
	kv->kv_key[1].kiov_base = nkey;
	/* +1 for '.' - no need to store '\0' in the key */
	kv->kv_key[1].kiov_len  = BKV_N_MAXKEYS_DIGITS + 1; 

	/* PAK:FIXME Version and DI not used. */
	kv->kv_newver = "000000000";
	kv->kv_newverlen = 8;
	kv->kv_disum = &sum;
	kv->kv_disumlen = sizeof(sum);
	kv->kv_ditype = KDI_CRC32;
	kv->kv_cpolicy = KC_WT;	

	/* Loop through the value buffer creating max value length KVs */
	pval = val;
	pvlen = kil.kl_vallen;
	for (i=0;i<(*n);i++) {
		/* If the last key, see if it is a partial */
		if (i == ((*n) - 1)) {
			if (vlen % kil.kl_vallen)
				pvlen = (vlen % kil.kl_vallen);
		}
		
		kv->kv_val[0].kiov_base = pval;
		kv->kv_val[0].kiov_len = pvlen;
		
		/* Generate the suffix, start at 0, e.g. ".000" */
		sprintf(nkey, BKV_N_MAXKEYS_FORMAT, i);
		
		kstatus = ki_put(ktd, NULL, kv);
		if (kstatus != K_OK) {
			debug_fprintf("bkv_putn: Failed\n");
			goto putn_out;
		}
		
		/* update the pval ptr for the next KV */
		pval += pvlen;

		ki_clean(kv);
	}

	ki_destroy(kv);
	return(*n);

 putn_out:

	ki_destroy(kv);
	return(-1);
}


int
bkv_del(int ktd, void *key, size_t klen)
{
	kv_t		*kv;
	struct kiovec	kv_key[1]  = {{0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};
	klimits_t	kil;
	kstatus_t 	kstatus;

	if (!key || !klen ) {
		debug_fprintf("bkv_del: Illegal arguments\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_del: Unable to get kinetic limits\n");
		return(-1);
	}

	if (klen > kil.kl_keylen) {
		debug_fprintf("bkv_del: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_get: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 1;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/*
	 * Hang the key and value
	 */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;

	kv->kv_cpolicy = KC_WT;	

	kstatus = ki_del(ktd, NULL, kv);
	
	if(kstatus != K_OK) {
		debug_fprintf("bkv_del: failed: status code %d\n", kstatus);
		return(-1);
	}
	
	return(0);
}

/*
 * Delete n keys, keys are generated by appending zero paded index to 
 * the basekey.
 * e.g. key="key" n=3, deln will delete keys: "key.001" "key.002" "key.003"
 * n is limited to BKV_N_MAXKEYS keys
 */
int
bkv_deln(int ktd, void *key, size_t klen, uint32_t n)
{
	int		i;
	char 		nkey[BKV_N_MAXKEYS_DIGITS + 2];
	kstatus_t 	kstatus;
	kv_t		*kv = NULL;
	klimits_t	kil;
	struct kiovec	kv_key[2]  = {{0, 0}, {0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};

	if (!key || !klen || !n) {
		debug_fprintf("bkv_deln: Illegal arguments\n");
		return(-1);
	}

	if (n > BKV_N_MAXKEYS) {
		debug_fprintf("bkv_deln: Too many keys requested\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_deln: Unable to get kinetic limits\n");
		return(-1);
	}

	/* klen + ".000" */
	if ((klen + 1 + BKV_N_MAXKEYS_DIGITS) > kil.kl_keylen) {
		debug_fprintf("bkv_deln: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_deln: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 2;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/* Hang the key buffers: key then suffix */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;
	
	kv->kv_key[1].kiov_base = nkey;
	kv->kv_key[1].kiov_len  = BKV_N_MAXKEYS_DIGITS + 1;

	kv->kv_cpolicy = KC_WT;	

	/* Loop through the key space deleting the keys */
	for (i=0;i<n;i++) {

		/* Generate the suffix, start at 0, e.g. ".000" */
		sprintf(nkey, BKV_N_MAXKEYS_FORMAT, i);
		
		kstatus = ki_del(ktd, NULL, kv);
		if (kstatus != K_OK) {
			debug_fprintf("bkv_deln: Failed\n");
			goto deln_out;
		}

		ki_clean(kv);
	}

	ki_destroy(kv);

	return(n);

 deln_out:
	if (kv) ki_destroy(kv);
	return(-1);
}


int
bkv_exists(int ktd, void *key, size_t klen)
{
	kv_t		*kv;
	struct kiovec	kv_key[1]  = {{0, 0}};
	struct kiovec	kv_val[1]  = {{0, 0}};
	klimits_t	kil;
	kstatus_t 	kstatus;

	if (!key || !klen) {
		debug_fprintf("bkv_get: Illegal arguments\n");
		return(-1);
	}

	kil = ki_limits(ktd);
	if (!kil.kl_keylen) {
		debug_fprintf("bkv_get: Unable to get kinetic limits\n");
		return(-1);
	}

	if (klen > kil.kl_keylen) {
		debug_fprintf("bkv_get: Illegal key length\n");
		return(-1);
	}

	kv = ki_create(ktd, KV_T);
	if (!kv) {
		debug_fprintf("bkv_get: No Mem\n");
		return(-1);
	}

	/* Init kv */
	kv->kv_key    = kv_key;
	kv->kv_keycnt = 1;
	kv->kv_val    = kv_val;
	kv->kv_valcnt = 1;

	/*
	 * Hang the key
	 */
	kv->kv_key[0].kiov_base = key;
	kv->kv_key[0].kiov_len  = klen;

	kstatus = ki_getversion(ktd, kv);

	switch (kstatus) {
	case K_OK:
		return(1);
		break;
	case K_ENOTFOUND:
		debug_fprintf("bkv_get: No key found.\n");
		return(0);
	default:	
		debug_fprintf("bkv_get: failed: status code %d\n", kstatus);
		return(-1);
	}
	
	return(0);
}

